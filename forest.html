<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movement Test</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            position: relative;
            height: 100vh;
        }
        #staminaBar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 100px;
            height: 20px;
            background-color: gray;
            border: 1px solid black;
        }
        #stamina {
            height: 100%;
            background-color: green;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="staminaBar">
        <div id="stamina"></div>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x00000, 0.1); // Very thick exponential fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        resizeRendererToDisplaySize();
        document.body.appendChild(renderer.domElement);

        // Player setup
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 }); // Transparent material
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.5; // Adjust player's initial position
        scene.add(player);

        // Environment setup
        const environmentGeometry = new THREE.BoxGeometry(100, 0.1, 100);
        const environmentMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
        const environment = new THREE.Mesh(environmentGeometry, environmentMaterial);
        scene.add(environment);

        // Add textures to the environment
        const textureLoader = new THREE.TextureLoader();
        const groundTexture = textureLoader.load('https://t4.ftcdn.net/jpg/00/74/04/43/360_F_74044371_fHXDQ9UrOTRkZffoef1QXtuYX7suMNXr.jpg');
        environmentMaterial.map = groundTexture;

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 0);
        scene.add(directionalLight);

        // Function to generate a random number within a range
        function randomInRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Load textures
        const trunkTexture = new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQONIy6utWh10QE0OhE33D7kslxNFYERhDTmdiumwgAnQ&s');
        const foliageTexture = new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTSmLw5r1AtO8xhvHTQwR4BpcCdHIYcDOkXpBMpiQJrog&s');

        // Create trees
        const numTrees = 30; // Number of trees to generate

        for (let i = 0; i < numTrees; i++) {
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.2, 2, 8);
            const trunkMaterial = new THREE.MeshBasicMaterial({ map: trunkTexture });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

            // Foliage
            const foliageGeometry = new THREE.ConeGeometry(1, 2, 8);
            const foliageMaterial = new THREE.MeshBasicMaterial({ map: foliageTexture });
            const foliage1 = new THREE.Mesh(foliageGeometry, foliageMaterial);
            const foliage2 = new THREE.Mesh(foliageGeometry, foliageMaterial);

            // Random position within a defined area
            const x = randomInRange(-50, 50);
            const z = randomInRange(-50, 50);

            trunk.position.set(x, 0.5, z);
            foliage1.position.set(x, 2, z);
            foliage2.position.set(x, 3, z);

            scene.add(trunk, foliage1, foliage2);
        }

        // Keyboard input
        const keyboard = {};
        document.addEventListener('keydown', (event) => {
            keyboard[event.key] = true;
            if (event.key === 'Shift') {
                isSprinting = true;
            }
            if (event.key === 'Control') {
                if (!isControlPressed && Date.now() - lastControlPressTime > 3000) {
                    isControlPressed = true;
                    lastControlPressTime = Date.now();
                    simulateKeyPress('w'); // Simulate pressing 'W' when control is pressed
                }
            }
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.key] = false;
            if (event.key === 'Shift') {
                isSprinting = false;
            }
            if (event.key === 'Control') {
                isControlPressed = false;
            }
        });

        // Function to simulate a key press
        function simulateKeyPress(key) {
            const event = new KeyboardEvent('keydown', { key: key });
            document.dispatchEvent(event);
        }

        // Mouse movement
        const mouse = new THREE.Vector2();
        const sensitivity = 0.01;
        let isPointerLocked = false;

        function handleMouseMove(event) {
            if (isPointerLocked) {
                mouse.x += event.movementX * sensitivity;
                mouse.y += event.movementY * sensitivity;
                // Limit vertical rotation between -π/2 to π/2
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x + event.movementY * sensitivity));
                // Horizontal rotation
                camera.rotation.y -= event.movementX * sensitivity;
            }
        }

        document.addEventListener('mousemove', handleMouseMove);

        // Lock cursor to center
        const canvas = renderer.domElement;

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
            if (isPointerLocked) {
                mouse.x = 0;
                mouse.y = 0;
            }
        });

        // Collision detection
        function detectCollisions() {
            const playerPos = player.position;
            const envPos = environment.position;
            const envSize = environment.geometry.parameters;

            if (
                playerPos.x < envPos.x - envSize.width / 2 ||
                playerPos.x > envPos.x + envSize.width / 2 ||
                playerPos.z < envPos.z - envSize.depth / 2 ||
                playerPos.z > envPos.z + envSize.depth / 2
            ) {
                player.position.copy(player.prevPosition);
            }
        }

        // Sprinting
        let isSprinting = false;
        let isControlPressed = false;
        let lastControlPressTime = 0;
        let stamina = 100;
        const sprintSpeed = 0.2;
        const baseSpeed = 0.1;
        const controlSpeed = 0.8; 
        const staminaDecreaseRate = 20; // Decrease per second
        const staminaIncreaseRate = 10; // Increase per second
        const maxStamina = 100;

        // Update player position and camera orientation
        function animate() {
            requestAnimationFrame(animate);

            const speed = isSprinting ? sprintSpeed : (isControlPressed ? controlSpeed : baseSpeed);
            const jumpSpeed = 0.2;
            const gravity = 0.4;

            const direction = new THREE.Vector3();

            if (isPointerLocked) {
                if (keyboard['w']) {
                    direction.x -= Math.sin(camera.rotation.y);
                    direction.z -= Math.cos(camera.rotation.y);
                }
                if (keyboard['s']) {
                    direction.x += Math.sin(camera.rotation.y);
                    direction.z += Math.cos(camera.rotation.y);
                }
                if (keyboard['d']) {
                    direction.x -= Math.sin(camera.rotation.y - Math.PI / 2);
                    direction.z -= Math.cos(camera.rotation.y - Math.PI / 2);
                }
                if (keyboard['a']) {
                    direction.x += Math.sin(camera.rotation.y - Math.PI / 2);
                    direction.z += Math.cos(camera.rotation.y - Math.PI / 2);
                }

                direction.normalize().multiplyScalar(speed);
                player.position.add(direction);
                player.prevPosition = player.position.clone();

                detectCollisions();

                if (keyboard[' ']) {
                    if (player.position.y <= 0.5) {
                        player.jumping = true;
                    }
                }

                if (player.jumping) {
                    player.position.y += jumpSpeed;
                    if (player.position.y >= 2) {
                        player.jumping = false;
                    }
                } else if (player.position.y > 0) {
                    player.position.y -= gravity;
                }

                // Update stamina
                if (isSprinting) {
                    stamina -= staminaDecreaseRate / 60; // Divide by 60 to convert to per-frame decrease
                    if (stamina <= 0) {
                        stamina = 0;
                        isSprinting = false;
                    }
                } else {
                    if (stamina < maxStamina) {
                        stamina += staminaIncreaseRate / 60; // Divide by 60 to convert to per-frame increase
                    }
                    if (stamina > maxStamina) {
                        stamina = maxStamina;
                    }
                }
                updateStaminaBar();
            }

            camera.position.copy(player.position);
            camera.position.y += 1;

            renderer.render(scene, camera);
        }

        function updateStaminaBar() {
            const staminaBar = document.getElementById('stamina');
            staminaBar.style.width = stamina + '%';
        }

        function resizeRendererToDisplaySize() {
            const canvas = renderer.domElement;
            const width = window.innerWidth;
            const height = window.innerHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            return needResize;
        }

        window.addEventListener('resize', resizeRendererToDisplaySize);

        animate();
    </script>
</body>
</html>
